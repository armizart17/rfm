function [u_opt,fcosts] = rpl_tv_a_prior(Y,X,Z,mu,u_0,params)
% -------------------------------------------------------------------------
% DESCRIPTION
% Regularized Power Law by Total Variation
% -------------------------------------------------------------------------
% INPUTS
%       filename        Name of the file generated by a simulator o by the
%                       scanner that contains the raw data
%       test_params     Structure with the following fields:
%                       - c0: Speed of sound [m/s]
%                       - BW: Bandwidth [MHz]
%                       - lambda: Bandwidth [MHz]
% -------------------------------------------------------------------------
% OUTPUTS
%       data            Structure with the following fields:
%                       - rfdata_ref: RF data from reference phantom
% -------------------------------------------------------------------------
% AUTHOR: Hector Chahuara
% CONTACT: hector.chahuara@pucp.edu.pe
% -------------------------------------------------------------------------
% RELATED PUBLICATIONS
% [1] H. Chahuara, A. Basarab and R. Lavarello, "Variational imaging
% methods for spectral-based ultrasonic tissue characterization," in
% preparation, 2021
% [2] H. Chahuara, A. Basarab and R. Lavarello, "Regularized framework for
% simultaneous estimation of ultrasonic attenuation and backscatter
% coefficients," 2020 IEEE International Ultrasonics Symposium (IUS), 2020,
% pp. 1-4, doi: 10.1109/IUS46767.2020.9251584
% -------------------------------------------------------------------------

    % implementation parameters
    if nargin < 6
        tol   = 1e-8;
        kmax  = 100;
        eps_f = 1e-8;
        df_op = 0;
    else
        tol   = params.tol;
        kmax  = params.kmax;
        eps_f = params.eps_f;
        df_op = params.df_op;
    end

    % spectrum ratio
    y = Y(:);

    % size
    [p,q] = size(Y,[2,3]); % old
    % [p,q,r] = size(Y);

    % hyperparameters
    mu_b = mu(1); mu_n = mu(2);

    % differential operators
    if df_op == 1
        dx = 0.5*(diag(ones(q-1,1),1) - diag(ones(q-1,1),-1));
        dx(1,1) = -1; dx(1,2) = 1; dx(end,end) = 1; dx(end,end-1) = -1;
        dy = 0.5*(diag(ones(p-1,1),1) - diag(ones(p-1,1),-1));
        dy(1,1) = -1; dy(1,2) = 1; dy(end,end) = 1; dy(end,end-1) = -1;
    else
        dx = diag(ones(q-1,1),1) - diag([ones(q-1,1);0]);
        dy = diag(ones(p-1,1),1) - diag([ones(p-1,1);0]);
    end

    % differential matrices for b and n
    Dx = sparse(kron(dx,speye(p)));
    Dy = sparse(kron(speye(q),dy));

    % differential matrix-based operators
    D = [Dx;Dy]; Dt = D';

    % precomputation of matrices
    XtX = X'*X; ZtZ = Z'*Z;
    XtZ = X'*Z; ZtX = XtZ';

    % precomputation of vectors
    Xty = X'*y; Zty = Z'*y;

    % preallocation of vector for reporting functional costs
    fid  = zeros(kmax,1);
    tv_b = zeros(kmax,1);
    tv_n = zeros(kmax,1);
    f    = zeros(kmax,1);
    err  = ones(kmax,1);

    % initializing iterations
    k = 1;

    % tolerance for f_R function
    eps_s = 1e-4;

    % initial solution
    b = u_0(1:p*q);
    n = u_0(p*q+1:2*p*q);
 
    % errors for each term in the optimization problem
    e_fid = X*b+Z*n - y;
    e_b   = norm2_fun(D*b,p*q);
    e_n   = norm2_fun(D*n,p*q);

    % costs at k = 1
    fid(1)  = 0.5*(norm(e_fid))^2;
    tv_b(1) = mu_b*sum(e_b);
    tv_n(1) = mu_n*sum(e_n);
    f(1)    = fid(1)+tv_b(1)+tv_n(1);
    err(1)  = abs(f(1));

    % error
    e = err(1);

    while e > tol

        % spatial weights for approximating Total Variation
        s_b = f_R(norm2_fun(D*b,p*q).^2,eps_s,eps_f);
        s_n = f_R(norm2_fun(D*n,p*q).^2,eps_s,eps_f);

        % duplicating spatial weights
        omega_b = spdiags(kron(ones(2,1),s_b),0,speye(2*p*q));
        omega_n = spdiags(kron(ones(2,1),s_n),0,speye(2*p*q));

        % matrices for the linear systems
        Q_b = XtX + mu_b*Dt*omega_b*D;
        Q_n = ZtZ + mu_n*Dt*omega_n*D;

        % solving for b
        y_b   = Xty - (XtZ*n);
        [b,~] = cgs(Q_b,y_b,tol,10000);

        % solving for n
        y_n   = Zty - (ZtX*b);
        [n,~] = cgs(Q_n,y_n,tol,10000);

        % errors for each term in the optimization problem
        e_fid = X*b+Z*n - y;
        e_b   = (omega_b.^0.5)*D*b;
        e_n   = (omega_n.^0.5)*D*n;

        % costs at k+1
        fid(k+1)  = 0.5*(norm(e_fid))^2;
        tv_b(k+1) = 0.5*mu_b*(norm(e_b))^2;
        tv_n(k+1) = 0.5*mu_n*(norm(e_n))^2;
        f(k+1)    = fid(k+1)+tv_b(k+1)+tv_n(k+1);
        err(k+1)  = abs((f(k+1)-f(k))/f(k+1));

        % terminating condition by maximum number of iterations
        if kmax == k
            break;
        end

        % updating error
        e = err(k+1);

        % updating k
        k = k+1;

    end

    % optimal estimates
    u_opt = [b;n];

    % functional costs
    fcosts.fid   = fid(1:k);
    fcosts.reg_b = tv_b(1:k);
    fcosts.reg_n = tv_n(1:k);
    fcosts.f     = f(1:k);

end

% function f_R for approximating Total Variation
function s = f_R(d,eps_s,eps_f)
    s = zeros(length(d),1);
    d_s = sign(d).*(abs(d)+eps_s);
    s(d > eps_f) = 2*(d_s(d > eps_f)).^(-0.5);
end

% function for l2-norm of the rows of a matrix with n rows
function d = norm2_fun(m,n)
    l = length(m)/n;
    t = reshape(m,n,l);
    d = sum(t.^2,2).^0.5;
end